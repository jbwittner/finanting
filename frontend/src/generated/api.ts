/* tslint:disable */
/* eslint-disable */
/**
 * Swagger Finanting
 * This is a sample server Finanting server.
 *
 * The version of the OpenAPI document: 1.0.5
 * Contact: jeanbaptiste.wittner@outlook.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddUsersGroupParameter
 */
export interface AddUsersGroupParameter {
    /**
     * 
     * @type {string}
     * @memberof AddUsersGroupParameter
     */
    groupName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddUsersGroupParameter
     */
    usersName: Array<string>;
}
/**
 * 
 * @export
 * @interface AddressDTO
 */
export interface AddressDTO {
    /**
     * 
     * @type {string}
     * @memberof AddressDTO
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressDTO
     */
    street?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressDTO
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressDTO
     */
    zipCode?: string;
}
/**
 * 
 * @export
 * @interface AddressParameter
 */
export interface AddressParameter {
    /**
     * 
     * @type {string}
     * @memberof AddressParameter
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressParameter
     */
    street?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressParameter
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressParameter
     */
    zipCode?: string;
}
/**
 * 
 * @export
 * @interface BankDetailsDTO
 */
export interface BankDetailsDTO {
    /**
     * 
     * @type {string}
     * @memberof BankDetailsDTO
     */
    iban?: string;
    /**
     * 
     * @type {string}
     * @memberof BankDetailsDTO
     */
    accountNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof BankDetailsDTO
     */
    bankName?: string;
}
/**
 * 
 * @export
 * @interface BankDetailsParameter
 */
export interface BankDetailsParameter {
    /**
     * 
     * @type {string}
     * @memberof BankDetailsParameter
     */
    bankName?: string;
    /**
     * 
     * @type {string}
     * @memberof BankDetailsParameter
     */
    iban?: string;
    /**
     * 
     * @type {string}
     * @memberof BankDetailsParameter
     */
    accountNumber?: string;
}
/**
 * 
 * @export
 * @interface BankingAccountDTO
 */
export interface BankingAccountDTO {
    /**
     * 
     * @type {number}
     * @memberof BankingAccountDTO
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof BankingAccountDTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof BankingAccountDTO
     */
    abbreviation?: string;
    /**
     * 
     * @type {number}
     * @memberof BankingAccountDTO
     */
    balance?: number;
    /**
     * 
     * @type {BankDetailsDTO}
     * @memberof BankingAccountDTO
     */
    bankDetailsDTO?: BankDetailsDTO;
    /**
     * 
     * @type {CurrencyDTO}
     * @memberof BankingAccountDTO
     */
    currencyDTO?: CurrencyDTO;
    /**
     * 
     * @type {AddressDTO}
     * @memberof BankingAccountDTO
     */
    addressDTO?: AddressDTO;
}
/**
 * 
 * @export
 * @interface BankingAccountParameter
 */
export interface BankingAccountParameter {
    /**
     * 
     * @type {string}
     * @memberof BankingAccountParameter
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof BankingAccountParameter
     */
    abbreviation: string;
    /**
     * 
     * @type {string}
     * @memberof BankingAccountParameter
     */
    defaultCurrencyISOCode: string;
    /**
     * 
     * @type {number}
     * @memberof BankingAccountParameter
     */
    initialBalance: number;
    /**
     * 
     * @type {string}
     * @memberof BankingAccountParameter
     */
    groupName?: string;
    /**
     * 
     * @type {BankDetailsParameter}
     * @memberof BankingAccountParameter
     */
    bankDetailsParameter?: BankDetailsParameter;
    /**
     * 
     * @type {AddressParameter}
     * @memberof BankingAccountParameter
     */
    addressParameter?: AddressParameter;
}
/**
 * 
 * @export
 * @interface BankingTransactionDTO
 */
export interface BankingTransactionDTO {
    /**
     * 
     * @type {number}
     * @memberof BankingTransactionDTO
     */
    id?: number;
    /**
     * 
     * @type {BankingAccountDTO}
     * @memberof BankingTransactionDTO
     */
    bankingAccountDTO?: BankingAccountDTO;
    /**
     * 
     * @type {BankingAccountDTO}
     * @memberof BankingTransactionDTO
     */
    linkedBankingAccountDTO?: BankingAccountDTO;
    /**
     * 
     * @type {ThirdDTO}
     * @memberof BankingTransactionDTO
     */
    thirdDTO?: ThirdDTO;
    /**
     * 
     * @type {CategoryDTO}
     * @memberof BankingTransactionDTO
     */
    categoryDTO?: CategoryDTO;
    /**
     * 
     * @type {ClassificationDTO}
     * @memberof BankingTransactionDTO
     */
    classificationDTO?: ClassificationDTO;
    /**
     * 
     * @type {string}
     * @memberof BankingTransactionDTO
     */
    transactionDate?: string;
    /**
     * 
     * @type {string}
     * @memberof BankingTransactionDTO
     */
    amountDate?: string;
    /**
     * 
     * @type {number}
     * @memberof BankingTransactionDTO
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof BankingTransactionDTO
     */
    currencyAmount?: number;
    /**
     * 
     * @type {CurrencyDTO}
     * @memberof BankingTransactionDTO
     */
    currencyDTO?: CurrencyDTO;
    /**
     * 
     * @type {string}
     * @memberof BankingTransactionDTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof BankingTransactionDTO
     */
    createTimestamp?: string;
    /**
     * 
     * @type {string}
     * @memberof BankingTransactionDTO
     */
    updateTimestamp?: string;
}
/**
 * 
 * @export
 * @interface BankingTransactionParameter
 */
export interface BankingTransactionParameter {
    /**
     * 
     * @type {number}
     * @memberof BankingTransactionParameter
     */
    accountId: number;
    /**
     * 
     * @type {number}
     * @memberof BankingTransactionParameter
     */
    linkedAccountId?: number;
    /**
     * 
     * @type {number}
     * @memberof BankingTransactionParameter
     */
    thirdId?: number;
    /**
     * 
     * @type {number}
     * @memberof BankingTransactionParameter
     */
    classificationId?: number;
    /**
     * 
     * @type {number}
     * @memberof BankingTransactionParameter
     */
    categoryId?: number;
    /**
     * 
     * @type {string}
     * @memberof BankingTransactionParameter
     */
    transactionDate: string;
    /**
     * 
     * @type {string}
     * @memberof BankingTransactionParameter
     */
    amountDate: string;
    /**
     * 
     * @type {number}
     * @memberof BankingTransactionParameter
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof BankingTransactionParameter
     */
    currencyAmount: number;
    /**
     * 
     * @type {number}
     * @memberof BankingTransactionParameter
     */
    currencyId: number;
    /**
     * 
     * @type {string}
     * @memberof BankingTransactionParameter
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface CategoryDTO
 */
export interface CategoryDTO {
    /**
     * 
     * @type {number}
     * @memberof CategoryDTO
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryDTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDTO
     */
    abbreviation?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryDTO
     */
    categoryType?: CategoryDTOCategoryTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CategoryDTOCategoryTypeEnum {
    Expense = 'EXPENSE',
    Revenue = 'REVENUE'
}

/**
 * 
 * @export
 * @interface CategoryParameter
 */
export interface CategoryParameter {
    /**
     * 
     * @type {number}
     * @memberof CategoryParameter
     */
    parentId?: number;
    /**
     * 
     * @type {string}
     * @memberof CategoryParameter
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryParameter
     */
    abbreviation: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryParameter
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryParameter
     */
    groupName?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryParameter
     */
    categoryType?: CategoryParameterCategoryTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum CategoryParameterCategoryTypeEnum {
    Expense = 'EXPENSE',
    Revenue = 'REVENUE'
}

/**
 * 
 * @export
 * @interface ClassificationDTO
 */
export interface ClassificationDTO {
    /**
     * 
     * @type {number}
     * @memberof ClassificationDTO
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ClassificationDTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationDTO
     */
    abbreviation?: string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationDTO
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface ClassificationParameter
 */
export interface ClassificationParameter {
    /**
     * 
     * @type {string}
     * @memberof ClassificationParameter
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationParameter
     */
    abbreviation: string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationParameter
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationParameter
     */
    groupName?: string;
}
/**
 * 
 * @export
 * @interface ContactDTO
 */
export interface ContactDTO {
    /**
     * 
     * @type {string}
     * @memberof ContactDTO
     */
    homePhone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactDTO
     */
    portablePhone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactDTO
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactDTO
     */
    website?: string;
}
/**
 * 
 * @export
 * @interface ContactParameter
 */
export interface ContactParameter {
    /**
     * 
     * @type {string}
     * @memberof ContactParameter
     */
    homePhone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactParameter
     */
    portablePhone?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactParameter
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ContactParameter
     */
    website?: string;
}
/**
 * 
 * @export
 * @interface CurrencyDTO
 */
export interface CurrencyDTO {
    /**
     * 
     * @type {number}
     * @memberof CurrencyDTO
     */
    id?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencyDTO
     */
    defaultCurrency?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDTO
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyDTO
     */
    isoCode?: string;
    /**
     * 
     * @type {number}
     * @memberof CurrencyDTO
     */
    rate?: number;
    /**
     * 
     * @type {number}
     * @memberof CurrencyDTO
     */
    decimalPlaces?: number;
}
/**
 * 
 * @export
 * @interface CurrencyParameter
 */
export interface CurrencyParameter {
    /**
     * 
     * @type {boolean}
     * @memberof CurrencyParameter
     */
    defaultCurrency: boolean;
    /**
     * 
     * @type {string}
     * @memberof CurrencyParameter
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyParameter
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyParameter
     */
    isoCode: string;
    /**
     * 
     * @type {number}
     * @memberof CurrencyParameter
     */
    rate: number;
    /**
     * 
     * @type {number}
     * @memberof CurrencyParameter
     */
    decimalPlaces: number;
}
/**
 * 
 * @export
 * @interface GroupDTO
 */
export interface GroupDTO {
    /**
     * 
     * @type {string}
     * @memberof GroupDTO
     */
    groupName?: string;
    /**
     * 
     * @type {UserDTO}
     * @memberof GroupDTO
     */
    userAdmin?: UserDTO;
    /**
     * 
     * @type {Array<UserDTO>}
     * @memberof GroupDTO
     */
    groupUsers?: Array<UserDTO>;
}
/**
 * 
 * @export
 * @interface GroupParameter
 */
export interface GroupParameter {
    /**
     * 
     * @type {string}
     * @memberof GroupParameter
     */
    groupName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GroupParameter
     */
    usersName?: Array<string>;
}
/**
 * 
 * @export
 * @interface PasswordUpdateParameter
 */
export interface PasswordUpdateParameter {
    /**
     * 
     * @type {string}
     * @memberof PasswordUpdateParameter
     */
    previousPassword: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordUpdateParameter
     */
    newPassword: string;
}
/**
 * 
 * @export
 * @interface RemoveUsersGroupParameter
 */
export interface RemoveUsersGroupParameter {
    /**
     * 
     * @type {string}
     * @memberof RemoveUsersGroupParameter
     */
    groupName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RemoveUsersGroupParameter
     */
    usersName: Array<string>;
}
/**
 * 
 * @export
 * @interface ThirdDTO
 */
export interface ThirdDTO {
    /**
     * 
     * @type {number}
     * @memberof ThirdDTO
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ThirdDTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof ThirdDTO
     */
    abbreviation?: string;
    /**
     * 
     * @type {string}
     * @memberof ThirdDTO
     */
    description?: string;
    /**
     * 
     * @type {CategoryDTO}
     * @memberof ThirdDTO
     */
    categoryDTO?: CategoryDTO;
    /**
     * 
     * @type {BankDetailsDTO}
     * @memberof ThirdDTO
     */
    bankDetailsDTO?: BankDetailsDTO;
    /**
     * 
     * @type {AddressDTO}
     * @memberof ThirdDTO
     */
    addressDTO?: AddressDTO;
    /**
     * 
     * @type {ContactDTO}
     * @memberof ThirdDTO
     */
    contactDTO?: ContactDTO;
}
/**
 * 
 * @export
 * @interface ThirdParameter
 */
export interface ThirdParameter {
    /**
     * 
     * @type {string}
     * @memberof ThirdParameter
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof ThirdParameter
     */
    abbreviation: string;
    /**
     * 
     * @type {string}
     * @memberof ThirdParameter
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ThirdParameter
     */
    defaultCategoryId?: number;
    /**
     * 
     * @type {string}
     * @memberof ThirdParameter
     */
    groupName?: string;
    /**
     * 
     * @type {ContactParameter}
     * @memberof ThirdParameter
     */
    contactParameter?: ContactParameter;
    /**
     * 
     * @type {BankDetailsParameter}
     * @memberof ThirdParameter
     */
    bankDetailsParameter?: BankDetailsParameter;
    /**
     * 
     * @type {AddressParameter}
     * @memberof ThirdParameter
     */
    addressParameter?: AddressParameter;
}
/**
 * 
 * @export
 * @interface TreeCategoryDTO
 */
export interface TreeCategoryDTO {
    /**
     * 
     * @type {number}
     * @memberof TreeCategoryDTO
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TreeCategoryDTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeCategoryDTO
     */
    abbreviation?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeCategoryDTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeCategoryDTO
     */
    categoryType?: TreeCategoryDTOCategoryTypeEnum;
    /**
     * 
     * @type {Array<TreeCategoryDTO>}
     * @memberof TreeCategoryDTO
     */
    childTreeCategoriesDTOs?: Array<TreeCategoryDTO>;
}

/**
    * @export
    * @enum {string}
    */
export enum TreeCategoryDTOCategoryTypeEnum {
    Expense = 'EXPENSE',
    Revenue = 'REVENUE'
}

/**
 * 
 * @export
 * @interface UpdateBankingAccountParameter
 */
export interface UpdateBankingAccountParameter {
    /**
     * 
     * @type {string}
     * @memberof UpdateBankingAccountParameter
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBankingAccountParameter
     */
    abbreviation: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBankingAccountParameter
     */
    defaultCurrencyISOCode: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateBankingAccountParameter
     */
    initialBalance: number;
    /**
     * 
     * @type {BankDetailsParameter}
     * @memberof UpdateBankingAccountParameter
     */
    bankDetailsParameter?: BankDetailsParameter;
    /**
     * 
     * @type {AddressParameter}
     * @memberof UpdateBankingAccountParameter
     */
    addressParameter?: AddressParameter;
}
/**
 * 
 * @export
 * @interface UpdateCategoryParameter
 */
export interface UpdateCategoryParameter {
    /**
     * 
     * @type {number}
     * @memberof UpdateCategoryParameter
     */
    parentId?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateCategoryParameter
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCategoryParameter
     */
    abbreviation: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCategoryParameter
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCategoryParameter
     */
    categoryType?: UpdateCategoryParameterCategoryTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateCategoryParameterCategoryTypeEnum {
    Expense = 'EXPENSE',
    Revenue = 'REVENUE'
}

/**
 * 
 * @export
 * @interface UpdateClassificationParameter
 */
export interface UpdateClassificationParameter {
    /**
     * 
     * @type {string}
     * @memberof UpdateClassificationParameter
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateClassificationParameter
     */
    abbreviation: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateClassificationParameter
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface UpdateThirdParameter
 */
export interface UpdateThirdParameter {
    /**
     * 
     * @type {string}
     * @memberof UpdateThirdParameter
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateThirdParameter
     */
    abbreviation: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateThirdParameter
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateThirdParameter
     */
    defaultCategoryId?: number;
    /**
     * 
     * @type {ContactParameter}
     * @memberof UpdateThirdParameter
     */
    contactParameter?: ContactParameter;
    /**
     * 
     * @type {BankDetailsParameter}
     * @memberof UpdateThirdParameter
     */
    bankDetailsParameter?: BankDetailsParameter;
    /**
     * 
     * @type {AddressParameter}
     * @memberof UpdateThirdParameter
     */
    addressParameter?: AddressParameter;
}
/**
 * 
 * @export
 * @interface UserDTO
 */
export interface UserDTO {
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDTO
     */
    lastName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserDTO
     */
    roles?: Array<UserDTORolesEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum UserDTORolesEnum {
    Admin = 'ADMIN',
    User = 'USER'
}

/**
 * 
 * @export
 * @interface UserRegistrationParameter
 */
export interface UserRegistrationParameter {
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationParameter
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationParameter
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationParameter
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationParameter
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegistrationParameter
     */
    password: string;
}
/**
 * 
 * @export
 * @interface UserUpdateParameter
 */
export interface UserUpdateParameter {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateParameter
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateParameter
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateParameter
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateParameter
     */
    lastName: string;
}

/**
 * BankingAccountApi - axios parameter creator
 * @export
 */
export const BankingAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {BankingAccountParameter} [bankingAccountParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBankingAccount: async (bankingAccountParameter?: BankingAccountParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/bankingAccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankingAccountParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBankingAccount: async (bankingAccountId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankingAccountId' is not null or undefined
            assertParamExists('deleteBankingAccount', 'bankingAccountId', bankingAccountId)
            const localVarPath = `/bankingAccount/{bankingAccountId}`
                .replace(`{${"bankingAccountId"}}`, encodeURIComponent(String(bankingAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankingAccount: async (bankingAccountId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankingAccountId' is not null or undefined
            assertParamExists('getBankingAccount', 'bankingAccountId', bankingAccountId)
            const localVarPath = `/bankingAccount/{bankingAccountId}`
                .replace(`{${"bankingAccountId"}}`, encodeURIComponent(String(bankingAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupBankingAccounts: async (groupId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupBankingAccounts', 'groupId', groupId)
            const localVarPath = `/bankingAccount/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBankingAccounts: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/bankingAccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {UpdateBankingAccountParameter} [updateBankingAccountParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBankingAccount: async (bankingAccountId: number, updateBankingAccountParameter?: UpdateBankingAccountParameter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankingAccountId' is not null or undefined
            assertParamExists('updateBankingAccount', 'bankingAccountId', bankingAccountId)
            const localVarPath = `/bankingAccount/{bankingAccountId}`
                .replace(`{${"bankingAccountId"}}`, encodeURIComponent(String(bankingAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBankingAccountParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankingAccountApi - functional programming interface
 * @export
 */
export const BankingAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankingAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {BankingAccountParameter} [bankingAccountParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBankingAccount(bankingAccountParameter?: BankingAccountParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingAccountDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBankingAccount(bankingAccountParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBankingAccount(bankingAccountId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBankingAccount(bankingAccountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBankingAccount(bankingAccountId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingAccountDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBankingAccount(bankingAccountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupBankingAccounts(groupId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankingAccountDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupBankingAccounts(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserBankingAccounts(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankingAccountDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserBankingAccounts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {UpdateBankingAccountParameter} [updateBankingAccountParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBankingAccount(bankingAccountId: number, updateBankingAccountParameter?: UpdateBankingAccountParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingAccountDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBankingAccount(bankingAccountId, updateBankingAccountParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BankingAccountApi - factory interface
 * @export
 */
export const BankingAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankingAccountApiFp(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {BankingAccountParameter} [bankingAccountParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBankingAccount(bankingAccountParameter?: BankingAccountParameter, options?: any): AxiosPromise<BankingAccountDTO> {
            return localVarFp.createBankingAccount(bankingAccountParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBankingAccount(bankingAccountId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBankingAccount(bankingAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankingAccount(bankingAccountId: number, options?: any): AxiosPromise<BankingAccountDTO> {
            return localVarFp.getBankingAccount(bankingAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupBankingAccounts(groupId: number, options?: any): AxiosPromise<Array<BankingAccountDTO>> {
            return localVarFp.getGroupBankingAccounts(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBankingAccounts(options?: any): AxiosPromise<Array<BankingAccountDTO>> {
            return localVarFp.getUserBankingAccounts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {UpdateBankingAccountParameter} [updateBankingAccountParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBankingAccount(bankingAccountId: number, updateBankingAccountParameter?: UpdateBankingAccountParameter, options?: any): AxiosPromise<BankingAccountDTO> {
            return localVarFp.updateBankingAccount(bankingAccountId, updateBankingAccountParameter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankingAccountApi - object-oriented interface
 * @export
 * @class BankingAccountApi
 * @extends {BaseAPI}
 */
export class BankingAccountApi extends BaseAPI {
    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {BankingAccountParameter} [bankingAccountParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingAccountApi
     */
    public createBankingAccount(bankingAccountParameter?: BankingAccountParameter, options?: any) {
        return BankingAccountApiFp(this.configuration).createBankingAccount(bankingAccountParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} bankingAccountId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingAccountApi
     */
    public deleteBankingAccount(bankingAccountId: number, options?: any) {
        return BankingAccountApiFp(this.configuration).deleteBankingAccount(bankingAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} bankingAccountId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingAccountApi
     */
    public getBankingAccount(bankingAccountId: number, options?: any) {
        return BankingAccountApiFp(this.configuration).getBankingAccount(bankingAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} groupId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingAccountApi
     */
    public getGroupBankingAccounts(groupId: number, options?: any) {
        return BankingAccountApiFp(this.configuration).getGroupBankingAccounts(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingAccountApi
     */
    public getUserBankingAccounts(options?: any) {
        return BankingAccountApiFp(this.configuration).getUserBankingAccounts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} bankingAccountId aaaaaaaaaaaaa
     * @param {UpdateBankingAccountParameter} [updateBankingAccountParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingAccountApi
     */
    public updateBankingAccount(bankingAccountId: number, updateBankingAccountParameter?: UpdateBankingAccountParameter, options?: any) {
        return BankingAccountApiFp(this.configuration).updateBankingAccount(bankingAccountId, updateBankingAccountParameter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BankingTransactionApi - axios parameter creator
 * @export
 */
export const BankingTransactionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {BankingTransactionParameter} [bankingTransactionParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBankingTransaction: async (bankingTransactionParameter?: BankingTransactionParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/bankingTransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankingTransactionParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingTransactionId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBankingTransaction: async (bankingTransactionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankingTransactionId' is not null or undefined
            assertParamExists('deleteBankingTransaction', 'bankingTransactionId', bankingTransactionId)
            const localVarPath = `/bankingTransaction/{bankingTransactionId}`
                .replace(`{${"bankingTransactionId"}}`, encodeURIComponent(String(bankingTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankingAccountTransaction: async (bankingAccountId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankingAccountId' is not null or undefined
            assertParamExists('getBankingAccountTransaction', 'bankingAccountId', bankingAccountId)
            const localVarPath = `/bankingTransaction/{bankingAccountId}`
                .replace(`{${"bankingAccountId"}}`, encodeURIComponent(String(bankingAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingTransactionId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankingTransaction: async (bankingTransactionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankingTransactionId' is not null or undefined
            assertParamExists('getBankingTransaction', 'bankingTransactionId', bankingTransactionId)
            const localVarPath = `/bankingTransaction/{bankingTransactionId}`
                .replace(`{${"bankingTransactionId"}}`, encodeURIComponent(String(bankingTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingTransactionId aaaaaaaaaaaaa
         * @param {BankingTransactionParameter} [bankingTransactionParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBankingTransaction: async (bankingTransactionId: number, bankingTransactionParameter?: BankingTransactionParameter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bankingTransactionId' is not null or undefined
            assertParamExists('updateBankingTransaction', 'bankingTransactionId', bankingTransactionId)
            const localVarPath = `/bankingTransaction/{bankingTransactionId}`
                .replace(`{${"bankingTransactionId"}}`, encodeURIComponent(String(bankingTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bankingTransactionParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BankingTransactionApi - functional programming interface
 * @export
 */
export const BankingTransactionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BankingTransactionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {BankingTransactionParameter} [bankingTransactionParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBankingTransaction(bankingTransactionParameter?: BankingTransactionParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingTransactionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBankingTransaction(bankingTransactionParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingTransactionId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBankingTransaction(bankingTransactionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBankingTransaction(bankingTransactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBankingAccountTransaction(bankingAccountId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankingTransactionDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBankingAccountTransaction(bankingAccountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingTransactionId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBankingTransaction(bankingTransactionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingTransactionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBankingTransaction(bankingTransactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingTransactionId aaaaaaaaaaaaa
         * @param {BankingTransactionParameter} [bankingTransactionParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBankingTransaction(bankingTransactionId: number, bankingTransactionParameter?: BankingTransactionParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingTransactionDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBankingTransaction(bankingTransactionId, bankingTransactionParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BankingTransactionApi - factory interface
 * @export
 */
export const BankingTransactionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BankingTransactionApiFp(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {BankingTransactionParameter} [bankingTransactionParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBankingTransaction(bankingTransactionParameter?: BankingTransactionParameter, options?: any): AxiosPromise<BankingTransactionDTO> {
            return localVarFp.createBankingTransaction(bankingTransactionParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingTransactionId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBankingTransaction(bankingTransactionId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBankingTransaction(bankingTransactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingAccountId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankingAccountTransaction(bankingAccountId: number, options?: any): AxiosPromise<Array<BankingTransactionDTO>> {
            return localVarFp.getBankingAccountTransaction(bankingAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingTransactionId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBankingTransaction(bankingTransactionId: number, options?: any): AxiosPromise<BankingTransactionDTO> {
            return localVarFp.getBankingTransaction(bankingTransactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} bankingTransactionId aaaaaaaaaaaaa
         * @param {BankingTransactionParameter} [bankingTransactionParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBankingTransaction(bankingTransactionId: number, bankingTransactionParameter?: BankingTransactionParameter, options?: any): AxiosPromise<BankingTransactionDTO> {
            return localVarFp.updateBankingTransaction(bankingTransactionId, bankingTransactionParameter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BankingTransactionApi - object-oriented interface
 * @export
 * @class BankingTransactionApi
 * @extends {BaseAPI}
 */
export class BankingTransactionApi extends BaseAPI {
    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {BankingTransactionParameter} [bankingTransactionParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingTransactionApi
     */
    public createBankingTransaction(bankingTransactionParameter?: BankingTransactionParameter, options?: any) {
        return BankingTransactionApiFp(this.configuration).createBankingTransaction(bankingTransactionParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} bankingTransactionId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingTransactionApi
     */
    public deleteBankingTransaction(bankingTransactionId: number, options?: any) {
        return BankingTransactionApiFp(this.configuration).deleteBankingTransaction(bankingTransactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} bankingAccountId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingTransactionApi
     */
    public getBankingAccountTransaction(bankingAccountId: number, options?: any) {
        return BankingTransactionApiFp(this.configuration).getBankingAccountTransaction(bankingAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} bankingTransactionId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingTransactionApi
     */
    public getBankingTransaction(bankingTransactionId: number, options?: any) {
        return BankingTransactionApiFp(this.configuration).getBankingTransaction(bankingTransactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} bankingTransactionId aaaaaaaaaaaaa
     * @param {BankingTransactionParameter} [bankingTransactionParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BankingTransactionApi
     */
    public updateBankingTransaction(bankingTransactionId: number, bankingTransactionParameter?: BankingTransactionParameter, options?: any) {
        return BankingTransactionApiFp(this.configuration).updateBankingTransaction(bankingTransactionId, bankingTransactionParameter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoryApi - axios parameter creator
 * @export
 */
export const CategoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {CategoryParameter} [categoryParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory: async (categoryParameter?: CategoryParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} categoryId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory: async (categoryId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('deleteCategory', 'categoryId', categoryId)
            const localVarPath = `/category/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupCategories: async (groupId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupCategories', 'groupId', groupId)
            const localVarPath = `/category/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCategories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} categoryId aaaaaaaaaaaaa
         * @param {UpdateCategoryParameter} [updateCategoryParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory: async (categoryId: number, updateCategoryParameter?: UpdateCategoryParameter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('updateCategory', 'categoryId', categoryId)
            const localVarPath = `/category/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategoryParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {CategoryParameter} [categoryParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCategory(categoryParameter?: CategoryParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCategory(categoryParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} categoryId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCategory(categoryId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCategory(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupCategories(groupId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeCategoryDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupCategories(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserCategories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeCategoryDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserCategories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} categoryId aaaaaaaaaaaaa
         * @param {UpdateCategoryParameter} [updateCategoryParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategory(categoryId: number, updateCategoryParameter?: UpdateCategoryParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategory(categoryId, updateCategoryParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryApiFp(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {CategoryParameter} [categoryParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCategory(categoryParameter?: CategoryParameter, options?: any): AxiosPromise<void> {
            return localVarFp.createCategory(categoryParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} categoryId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(categoryId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupCategories(groupId: number, options?: any): AxiosPromise<Array<TreeCategoryDTO>> {
            return localVarFp.getGroupCategories(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserCategories(options?: any): AxiosPromise<Array<TreeCategoryDTO>> {
            return localVarFp.getUserCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} categoryId aaaaaaaaaaaaa
         * @param {UpdateCategoryParameter} [updateCategoryParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(categoryId: number, updateCategoryParameter?: UpdateCategoryParameter, options?: any): AxiosPromise<void> {
            return localVarFp.updateCategory(categoryId, updateCategoryParameter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {CategoryParameter} [categoryParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public createCategory(categoryParameter?: CategoryParameter, options?: any) {
        return CategoryApiFp(this.configuration).createCategory(categoryParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} categoryId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public deleteCategory(categoryId: number, options?: any) {
        return CategoryApiFp(this.configuration).deleteCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} groupId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getGroupCategories(groupId: number, options?: any) {
        return CategoryApiFp(this.configuration).getGroupCategories(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getUserCategories(options?: any) {
        return CategoryApiFp(this.configuration).getUserCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} categoryId aaaaaaaaaaaaa
     * @param {UpdateCategoryParameter} [updateCategoryParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public updateCategory(categoryId: number, updateCategoryParameter?: UpdateCategoryParameter, options?: any) {
        return CategoryApiFp(this.configuration).updateCategory(categoryId, updateCategoryParameter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClassificationApi - axios parameter creator
 * @export
 */
export const ClassificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {ClassificationParameter} [classificationParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClassification: async (classificationParameter?: ClassificationParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/classification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classificationParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} classificationId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassification: async (classificationId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'classificationId' is not null or undefined
            assertParamExists('deleteClassification', 'classificationId', classificationId)
            const localVarPath = `/classification/{classificationId}`
                .replace(`{${"classificationId"}}`, encodeURIComponent(String(classificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupClassifications: async (groupId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupClassifications', 'groupId', groupId)
            const localVarPath = `/classification/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClassification: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/classification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} classificationId aaaaaaaaaaaaa
         * @param {UpdateClassificationParameter} [updateClassificationParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClassification: async (classificationId: number, updateClassificationParameter?: UpdateClassificationParameter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'classificationId' is not null or undefined
            assertParamExists('updateClassification', 'classificationId', classificationId)
            const localVarPath = `/classification/{classificationId}`
                .replace(`{${"classificationId"}}`, encodeURIComponent(String(classificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateClassificationParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassificationApi - functional programming interface
 * @export
 */
export const ClassificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {ClassificationParameter} [classificationParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClassification(classificationParameter?: ClassificationParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClassification(classificationParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} classificationId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClassification(classificationId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClassification(classificationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupClassifications(groupId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassificationDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupClassifications(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserClassification(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClassificationDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserClassification(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} classificationId aaaaaaaaaaaaa
         * @param {UpdateClassificationParameter} [updateClassificationParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClassification(classificationId: number, updateClassificationParameter?: UpdateClassificationParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClassification(classificationId, updateClassificationParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClassificationApi - factory interface
 * @export
 */
export const ClassificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassificationApiFp(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {ClassificationParameter} [classificationParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClassification(classificationParameter?: ClassificationParameter, options?: any): AxiosPromise<void> {
            return localVarFp.createClassification(classificationParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} classificationId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassification(classificationId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteClassification(classificationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupClassifications(groupId: number, options?: any): AxiosPromise<Array<ClassificationDTO>> {
            return localVarFp.getGroupClassifications(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserClassification(options?: any): AxiosPromise<Array<ClassificationDTO>> {
            return localVarFp.getUserClassification(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} classificationId aaaaaaaaaaaaa
         * @param {UpdateClassificationParameter} [updateClassificationParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClassification(classificationId: number, updateClassificationParameter?: UpdateClassificationParameter, options?: any): AxiosPromise<void> {
            return localVarFp.updateClassification(classificationId, updateClassificationParameter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassificationApi - object-oriented interface
 * @export
 * @class ClassificationApi
 * @extends {BaseAPI}
 */
export class ClassificationApi extends BaseAPI {
    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {ClassificationParameter} [classificationParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationApi
     */
    public createClassification(classificationParameter?: ClassificationParameter, options?: any) {
        return ClassificationApiFp(this.configuration).createClassification(classificationParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} classificationId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationApi
     */
    public deleteClassification(classificationId: number, options?: any) {
        return ClassificationApiFp(this.configuration).deleteClassification(classificationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} groupId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationApi
     */
    public getGroupClassifications(groupId: number, options?: any) {
        return ClassificationApiFp(this.configuration).getGroupClassifications(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationApi
     */
    public getUserClassification(options?: any) {
        return ClassificationApiFp(this.configuration).getUserClassification(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} classificationId aaaaaaaaaaaaa
     * @param {UpdateClassificationParameter} [updateClassificationParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationApi
     */
    public updateClassification(classificationId: number, updateClassificationParameter?: UpdateClassificationParameter, options?: any) {
        return ClassificationApiFp(this.configuration).updateClassification(classificationId, updateClassificationParameter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CurrencyApi - axios parameter creator
 * @export
 */
export const CurrencyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {CurrencyParameter} [currencyParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrency: async (currencyParameter?: CurrencyParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/currency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} currencyId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrency: async (currencyId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('deleteCurrency', 'currencyId', currencyId)
            const localVarPath = `/currency/{currencyId}`
                .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCurrencies: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/currency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} currencyId aaaaaaaaaaaaa
         * @param {CurrencyParameter} [currencyParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency: async (currencyId: number, currencyParameter?: CurrencyParameter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'currencyId' is not null or undefined
            assertParamExists('updateCurrency', 'currencyId', currencyId)
            const localVarPath = `/currency/{currencyId}`
                .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(currencyParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyApi - functional programming interface
 * @export
 */
export const CurrencyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrencyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {CurrencyParameter} [currencyParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCurrency(currencyParameter?: CurrencyParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCurrency(currencyParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} currencyId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCurrency(currencyId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCurrency(currencyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCurrencies(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrencyDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCurrencies(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} currencyId aaaaaaaaaaaaa
         * @param {CurrencyParameter} [currencyParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCurrency(currencyId: number, currencyParameter?: CurrencyParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCurrency(currencyId, currencyParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrencyApi - factory interface
 * @export
 */
export const CurrencyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrencyApiFp(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {CurrencyParameter} [currencyParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrency(currencyParameter?: CurrencyParameter, options?: any): AxiosPromise<void> {
            return localVarFp.createCurrency(currencyParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} currencyId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCurrency(currencyId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCurrency(currencyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCurrencies(options?: any): AxiosPromise<Array<CurrencyDTO>> {
            return localVarFp.getAllCurrencies(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} currencyId aaaaaaaaaaaaa
         * @param {CurrencyParameter} [currencyParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCurrency(currencyId: number, currencyParameter?: CurrencyParameter, options?: any): AxiosPromise<void> {
            return localVarFp.updateCurrency(currencyId, currencyParameter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrencyApi - object-oriented interface
 * @export
 * @class CurrencyApi
 * @extends {BaseAPI}
 */
export class CurrencyApi extends BaseAPI {
    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {CurrencyParameter} [currencyParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public createCurrency(currencyParameter?: CurrencyParameter, options?: any) {
        return CurrencyApiFp(this.configuration).createCurrency(currencyParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} currencyId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public deleteCurrency(currencyId: number, options?: any) {
        return CurrencyApiFp(this.configuration).deleteCurrency(currencyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public getAllCurrencies(options?: any) {
        return CurrencyApiFp(this.configuration).getAllCurrencies(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} currencyId aaaaaaaaaaaaa
     * @param {CurrencyParameter} [currencyParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyApi
     */
    public updateCurrency(currencyId: number, currencyParameter?: CurrencyParameter, options?: any) {
        return CurrencyApiFp(this.configuration).updateCurrency(currencyId, currencyParameter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GroupApi - axios parameter creator
 * @export
 */
export const GroupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add user to a group
         * @param {AddUsersGroupParameter} [addUsersGroupParameter] Object that needs to be send to add a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserGroup: async (addUsersGroupParameter?: AddUsersGroupParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/group/addUserGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addUsersGroupParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new group
         * @param {GroupParameter} [groupParameter] Object that needs to be send to create a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (groupParameter?: GroupParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(groupParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a group
         * @param {number} groupId Group id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (groupId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroup', 'groupId', groupId)
            const localVarPath = `/group/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a group
         * @param {number} groupId Group id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup: async (groupId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroup', 'groupId', groupId)
            const localVarPath = `/group/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get groups of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove user to a group
         * @param {RemoveUsersGroupParameter} [removeUsersGroupParameter] Object that needs to be send to remove a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserGroup: async (removeUsersGroupParameter?: RemoveUsersGroupParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/group/removeUsersGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeUsersGroupParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupApi - functional programming interface
 * @export
 */
export const GroupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add user to a group
         * @param {AddUsersGroupParameter} [addUsersGroupParameter] Object that needs to be send to add a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserGroup(addUsersGroupParameter?: AddUsersGroupParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserGroup(addUsersGroupParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a new group
         * @param {GroupParameter} [groupParameter] Object that needs to be send to create a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(groupParameter?: GroupParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(groupParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a group
         * @param {number} groupId Group id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(groupId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a group
         * @param {number} groupId Group id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroup(groupId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroup(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get groups of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroups(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove user to a group
         * @param {RemoveUsersGroupParameter} [removeUsersGroupParameter] Object that needs to be send to remove a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserGroup(removeUsersGroupParameter?: RemoveUsersGroupParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserGroup(removeUsersGroupParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GroupApi - factory interface
 * @export
 */
export const GroupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupApiFp(configuration)
    return {
        /**
         * 
         * @summary Add user to a group
         * @param {AddUsersGroupParameter} [addUsersGroupParameter] Object that needs to be send to add a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserGroup(addUsersGroupParameter?: AddUsersGroupParameter, options?: any): AxiosPromise<GroupDTO> {
            return localVarFp.addUserGroup(addUsersGroupParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new group
         * @param {GroupParameter} [groupParameter] Object that needs to be send to create a group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(groupParameter?: GroupParameter, options?: any): AxiosPromise<GroupDTO> {
            return localVarFp.createGroup(groupParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a group
         * @param {number} groupId Group id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(groupId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a group
         * @param {number} groupId Group id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroup(groupId: number, options?: any): AxiosPromise<GroupDTO> {
            return localVarFp.getGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get groups of user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(options?: any): AxiosPromise<Array<GroupDTO>> {
            return localVarFp.getGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove user to a group
         * @param {RemoveUsersGroupParameter} [removeUsersGroupParameter] Object that needs to be send to remove a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserGroup(removeUsersGroupParameter?: RemoveUsersGroupParameter, options?: any): AxiosPromise<GroupDTO> {
            return localVarFp.removeUserGroup(removeUsersGroupParameter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupApi - object-oriented interface
 * @export
 * @class GroupApi
 * @extends {BaseAPI}
 */
export class GroupApi extends BaseAPI {
    /**
     * 
     * @summary Add user to a group
     * @param {AddUsersGroupParameter} [addUsersGroupParameter] Object that needs to be send to add a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public addUserGroup(addUsersGroupParameter?: AddUsersGroupParameter, options?: any) {
        return GroupApiFp(this.configuration).addUserGroup(addUsersGroupParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new group
     * @param {GroupParameter} [groupParameter] Object that needs to be send to create a group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public createGroup(groupParameter?: GroupParameter, options?: any) {
        return GroupApiFp(this.configuration).createGroup(groupParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a group
     * @param {number} groupId Group id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public deleteGroup(groupId: number, options?: any) {
        return GroupApiFp(this.configuration).deleteGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a group
     * @param {number} groupId Group id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroup(groupId: number, options?: any) {
        return GroupApiFp(this.configuration).getGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get groups of user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public getGroups(options?: any) {
        return GroupApiFp(this.configuration).getGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove user to a group
     * @param {RemoveUsersGroupParameter} [removeUsersGroupParameter] Object that needs to be send to remove a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupApi
     */
    public removeUserGroup(removeUsersGroupParameter?: RemoveUsersGroupParameter, options?: any) {
        return GroupApiFp(this.configuration).removeUserGroup(removeUsersGroupParameter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ThirdApi - axios parameter creator
 * @export
 */
export const ThirdApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {ThirdParameter} [thirdParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThird: async (thirdParameter?: ThirdParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/third`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(thirdParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} thirdId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThird: async (thirdId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'thirdId' is not null or undefined
            assertParamExists('deleteThird', 'thirdId', thirdId)
            const localVarPath = `/third/{thirdId}`
                .replace(`{${"thirdId"}}`, encodeURIComponent(String(thirdId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupThird: async (groupId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupThird', 'groupId', groupId)
            const localVarPath = `/third/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserThird: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/third`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} thirdId aaaaaaaaaaaaa
         * @param {UpdateThirdParameter} [updateThirdParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateThird: async (thirdId: number, updateThirdParameter?: UpdateThirdParameter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'thirdId' is not null or undefined
            assertParamExists('updateThird', 'thirdId', thirdId)
            const localVarPath = `/third/{thirdId}`
                .replace(`{${"thirdId"}}`, encodeURIComponent(String(thirdId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateThirdParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThirdApi - functional programming interface
 * @export
 */
export const ThirdApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThirdApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {ThirdParameter} [thirdParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createThird(thirdParameter?: ThirdParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createThird(thirdParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} thirdId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteThird(thirdId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteThird(thirdId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupThird(groupId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThirdDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupThird(groupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserThird(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThirdDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserThird(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} thirdId aaaaaaaaaaaaa
         * @param {UpdateThirdParameter} [updateThirdParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateThird(thirdId: number, updateThirdParameter?: UpdateThirdParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateThird(thirdId, updateThirdParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ThirdApi - factory interface
 * @export
 */
export const ThirdApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThirdApiFp(configuration)
    return {
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {ThirdParameter} [thirdParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createThird(thirdParameter?: ThirdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.createThird(thirdParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} thirdId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteThird(thirdId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteThird(thirdId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} groupId aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupThird(groupId: number, options?: any): AxiosPromise<Array<ThirdDTO>> {
            return localVarFp.getGroupThird(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserThird(options?: any): AxiosPromise<Array<ThirdDTO>> {
            return localVarFp.getUserThird(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary aaaaaaaaaaaaa
         * @param {number} thirdId aaaaaaaaaaaaa
         * @param {UpdateThirdParameter} [updateThirdParameter] aaaaaaaaaaaaa
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateThird(thirdId: number, updateThirdParameter?: UpdateThirdParameter, options?: any): AxiosPromise<void> {
            return localVarFp.updateThird(thirdId, updateThirdParameter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThirdApi - object-oriented interface
 * @export
 * @class ThirdApi
 * @extends {BaseAPI}
 */
export class ThirdApi extends BaseAPI {
    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {ThirdParameter} [thirdParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdApi
     */
    public createThird(thirdParameter?: ThirdParameter, options?: any) {
        return ThirdApiFp(this.configuration).createThird(thirdParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} thirdId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdApi
     */
    public deleteThird(thirdId: number, options?: any) {
        return ThirdApiFp(this.configuration).deleteThird(thirdId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} groupId aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdApi
     */
    public getGroupThird(groupId: number, options?: any) {
        return ThirdApiFp(this.configuration).getGroupThird(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdApi
     */
    public getUserThird(options?: any) {
        return ThirdApiFp(this.configuration).getUserThird(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary aaaaaaaaaaaaa
     * @param {number} thirdId aaaaaaaaaaaaa
     * @param {UpdateThirdParameter} [updateThirdParameter] aaaaaaaaaaaaa
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThirdApi
     */
    public updateThird(thirdId: number, updateThirdParameter?: UpdateThirdParameter, options?: any) {
        return ThirdApiFp(this.configuration).updateThird(thirdId, updateThirdParameter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get account informations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the password of the user
         * @param {PasswordUpdateParameter} [passwordUpdateParameter] Object that needs to be send to update a user password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPasswordUpdate: async (passwordUpdateParameter?: PasswordUpdateParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/updatePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordUpdateParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register a new user account
         * @param {UserRegistrationParameter} [userRegistrationParameter] Object that needs to be send to register a new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegistration: async (userRegistrationParameter?: UserRegistrationParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegistrationParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update account informations
         * @param {UserUpdateParameter} [userUpdateParameter] Object that needs to be send to update a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate: async (userUpdateParameter?: UserUpdateParameter, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get account informations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update the password of the user
         * @param {PasswordUpdateParameter} [passwordUpdateParameter] Object that needs to be send to update a user password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPasswordUpdate(passwordUpdateParameter?: PasswordUpdateParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPasswordUpdate(passwordUpdateParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register a new user account
         * @param {UserRegistrationParameter} [userRegistrationParameter] Object that needs to be send to register a new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userRegistration(userRegistrationParameter?: UserRegistrationParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userRegistration(userRegistrationParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update account informations
         * @param {UserUpdateParameter} [userUpdateParameter] Object that needs to be send to update a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUpdate(userUpdateParameter?: UserUpdateParameter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdate(userUpdateParameter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Get account informations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(options?: any): AxiosPromise<UserDTO> {
            return localVarFp.userGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the password of the user
         * @param {PasswordUpdateParameter} [passwordUpdateParameter] Object that needs to be send to update a user password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPasswordUpdate(passwordUpdateParameter?: PasswordUpdateParameter, options?: any): AxiosPromise<void> {
            return localVarFp.userPasswordUpdate(passwordUpdateParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register a new user account
         * @param {UserRegistrationParameter} [userRegistrationParameter] Object that needs to be send to register a new user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userRegistration(userRegistrationParameter?: UserRegistrationParameter, options?: any): AxiosPromise<UserDTO> {
            return localVarFp.userRegistration(userRegistrationParameter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update account informations
         * @param {UserUpdateParameter} [userUpdateParameter] Object that needs to be send to update a user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdate(userUpdateParameter?: UserUpdateParameter, options?: any): AxiosPromise<UserDTO> {
            return localVarFp.userUpdate(userUpdateParameter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Get account informations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGet(options?: any) {
        return UserApiFp(this.configuration).userGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the password of the user
     * @param {PasswordUpdateParameter} [passwordUpdateParameter] Object that needs to be send to update a user password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPasswordUpdate(passwordUpdateParameter?: PasswordUpdateParameter, options?: any) {
        return UserApiFp(this.configuration).userPasswordUpdate(passwordUpdateParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register a new user account
     * @param {UserRegistrationParameter} [userRegistrationParameter] Object that needs to be send to register a new user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userRegistration(userRegistrationParameter?: UserRegistrationParameter, options?: any) {
        return UserApiFp(this.configuration).userRegistration(userRegistrationParameter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update account informations
     * @param {UserUpdateParameter} [userUpdateParameter] Object that needs to be send to update a user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUpdate(userUpdateParameter?: UserUpdateParameter, options?: any) {
        return UserApiFp(this.configuration).userUpdate(userUpdateParameter, options).then((request) => request(this.axios, this.basePath));
    }
}


